# CLAUDE.md - Email Budget

## Project Overview

Email Budget is a Tauri 2.x cross-platform app (desktop + iOS) that helps recent college graduates track spending by parsing email receipts. It extracts transaction data from uploaded HTML files or camera-captured receipts, auto-categorizes expenses, and provides budget visibility through a dashboard.

**Key docs:**
- `docs/PRD.md` — Product requirements, user stories, feature scope
- `docs/TECH_SPEC.md` — Architecture, data models, implementation details
- `docs/DESIGN.md` — Visual design system, UI patterns, components

## Tech Stack

- **Desktop Framework**: Tauri 2.x (Rust backend)
- **Frontend**: React 18 + TypeScript 5 + Vite
- **Styling**: Tailwind CSS + shadcn/ui
- **Charts**: Recharts
- **State**: Zustand
- **Local DB**: SQLite (via tauri-plugin-sql)
- **Cloud**: Supabase (PostgreSQL, future auth)

## Project Structure

```
email_budget/
├── src-tauri/                    # Rust backend
│   ├── src/
│   │   ├── commands/             # Tauri IPC handlers
│   │   ├── parser/               # Receipt parsing engine
│   │   │   └── vendors/          # Per-vendor parsers
│   │   ├── categorizer/          # Auto-categorization
│   │   ├── db/                   # Database layer
│   │   ├── gmail/                # Gmail OAuth + sync
│   │   ├── ocr/                  # Receipt OCR text parsing
│   │   └── sync/                 # Cloud sync
│   ├── gen/apple/                # Xcode project (generated by Tauri)
│   │   └── Sources/email-budget/ # Swift sources for iOS
│   └── swift-plugins/            # Standalone Swift plugin sources
│       └── receipt-capture/      # Camera + Vision OCR plugin
├── src/                          # React frontend
│   ├── components/               # UI components
│   │   ├── mobile/               # Mobile-specific components
│   │   └── gmail/                # Gmail integration UI
│   ├── hooks/                    # Custom React hooks
│   ├── stores/                   # Zustand stores
│   ├── pages/                    # Route pages
│   │   └── mobile/               # Mobile-specific pages
│   ├── lib/                      # Utilities
│   └── types/                    # TypeScript types
└── docs/                         # Documentation
```

## Development Commands

```bash
# Install dependencies
pnpm install

# Run in development mode (desktop)
pnpm tauri dev

# Build for production (desktop)
pnpm tauri build

# Run frontend only (for UI development)
pnpm dev

# Run Rust tests
cd src-tauri && cargo test

# Run frontend tests
pnpm test

# iOS development (must boot simulator first!)
xcrun simctl boot "iPhone 16"    # Boot simulator BEFORE running dev
pnpm tauri ios dev                # Run on iOS simulator

# iOS build
pnpm tauri ios build
```

## Architecture Principles

1. **Local-first**: SQLite is source of truth. App works fully offline.
2. **Privacy-preserving**: Raw HTML emails are NEVER stored. Parse in memory, discard after extraction.
3. **Sync as backup**: Cloud sync is for backup/restore only, not real-time collaboration.
4. **Parser modularity**: Each vendor has isolated parser in `src-tauri/src/parser/vendors/`.

## Code Conventions

### Rust (src-tauri)

- Use `Result<T, E>` for fallible operations, never panic in command handlers
- Parsers implement the `VendorParser` trait
- Store amounts as `i64` cents (not floats) to avoid precision issues
- Use `chrono::NaiveDate` for dates
- SQL queries go in `db/queries.rs`, not inline in commands
- Run `cargo fmt` and `cargo clippy` before commits

### TypeScript/React (src)

- Functional components with hooks only
- Custom hooks in `src/hooks/` for data fetching and state
- Zustand stores in `src/stores/` — one store per domain (transactions, categories, budgets)
- Use `@tauri-apps/api` invoke wrapper in `src/lib/tauri.ts`
- Amounts come from backend as cents — format to dollars in UI only
- Date formatting via `src/lib/format.ts` utilities

### Styling

- Tailwind utility classes, avoid custom CSS
- shadcn/ui components in `src/components/ui/`
- Color tokens defined in `tailwind.config.js`
- Dark mode support from day one (use `dark:` variants)

## Key Implementation Details

### Parsing Flow

1. User drops HTML files in upload zone
2. Frontend reads file contents, sends to Rust via `import_receipts` command
3. Rust detects vendor, routes to appropriate parser
4. Parser extracts: merchant, amount, date, items
5. Returns `ParsedTransaction[]` to frontend for preview
6. User confirms, frontend calls `confirm_import`
7. Rust saves to SQLite, raw HTML is never written to disk

### Auto-Categorization Priority

1. User overrides (`merchant_category_rules` table)
2. Exact merchant match from previous transactions
3. Pattern match (merchant contains known substring)
4. Provider-based default (DoorDash → Food Delivery)
5. Falls back to "Uncategorized"

### Deduplication

Transactions are deduplicated via `source_hash`:
```
SHA256(merchant_normalized + amount + transaction_date)
```
This prevents re-importing the same receipt without storing the raw content.

## Adding a New Vendor Parser

1. Create `src-tauri/src/parser/vendors/{vendor}.rs`
2. Implement `VendorParser` trait with `vendor_id()`, `can_parse()`, `parse()`
3. Add to vendor registry in `src-tauri/src/parser/vendors/mod.rs`
4. Add detection patterns to `src-tauri/src/parser/engine.rs`
5. Add test fixtures in `src-tauri/tests/fixtures/{vendor}/`
6. Update `SUPPORTED_PROVIDERS` in `src/types/provider.ts`

## Testing

- **Parser tests**: Unit tests with HTML fixture files per vendor
- **DB tests**: Integration tests with in-memory SQLite
- **Component tests**: React Testing Library
- **E2E**: Playwright for critical flows

Fixture files live in `src-tauri/tests/fixtures/{vendor}/*.html`

## Common Tasks

### Add a new category
1. Add to `DEFAULT_CATEGORIES` in `src/lib/constants.ts`
2. Add migration in `src-tauri/src/db/migrations/`
3. Update categorizer defaults if needed

### Add a new dashboard widget
1. Create component in `src/components/dashboard/`
2. Add query to `get_dashboard_stats` command if new data needed
3. Add to dashboard layout in `src/pages/Dashboard.tsx`

### Modify sync schema
1. Update local SQLite schema + migration
2. Update Supabase schema to match
3. Update sync logic in `src-tauri/src/sync/supabase.rs`
4. Test with fresh database

## Environment Variables

```bash
# .env.local (frontend)
VITE_SUPABASE_URL=https://xxx.supabase.co
VITE_SUPABASE_ANON_KEY=xxx

# src-tauri/.env (backend, if needed)
SUPABASE_SERVICE_KEY=xxx  # Only for admin operations
```

## iOS Mobile App

The app has a separate mobile UI that is activated via platform detection.

### Architecture
- **Platform detection**: Rust `get_platform` command + sync UA fallback in `usePlatform` hook
- **Mobile layout**: `MobileLayout` (SafeArea + TabBar) vs desktop `Layout` (Sidebar)
- **Mobile pages**: `src/pages/mobile/` — Dashboard, Transactions, Import, Budgets, Settings
- **Mobile components**: `src/components/mobile/` — SafeArea, TabBar, MobileHeader, MobileLayout, PullToRefresh, SwipeableRow, BottomSheet

### Receipt Capture (Camera OCR)
- Swift plugin in `src-tauri/gen/apple/Sources/email-budget/ReceiptCapturePlugin.swift` — uses UIImagePicker + Apple Vision OCR
- Bridge in `ReceiptCaptureBridge.swift` — WKScriptMessageHandler connects JS → Swift
- Frontend calls via `window.webkit.messageHandlers.captureReceipt` on iOS
- OCR text parser in `src-tauri/src/ocr/receipt_text_parser.rs`
- Haptics via `tauri-plugin-haptics` crate

### Mobile OAuth
- Uses custom URL scheme `emailbudget://oauth-callback`
- `oauth_mobile.rs` handles mobile-specific token exchange with PKCE

## Gmail Integration

### OAuth Flow (PKCE)
- Credentials are hardcoded in `src-tauri/src/gmail/config.rs` (Google Desktop OAuth app)
- Desktop: opens browser → localhost:8249 callback server → token exchange
- Mobile: opens system browser → custom URL scheme callback → token exchange
- Both flows use PKCE (S256 code challenge) for security
- Users just click "Sign in with Google" — no manual credential setup needed
- Token refresh uses hardcoded client_id/client_secret (required by Google for Desktop apps)

### Sync Architecture
- Poller runs on interval, fetches new emails matching sender filters
- Initial sync: last 90 days of receipt emails
- Incremental sync: uses Gmail history.list API
- Processed message IDs tracked in `gmail_processed_messages` table

## Gotchas

- Tauri commands are async — always `await` invoke calls
- SQLite doesn't have `RETURNING *` — fetch after insert if needed
- HTML parsers are vendor-specific — when vendors change email formats, parsers break
- Amounts are cents everywhere in backend — only format to `$X.XX` in UI display
- Zustand stores persist to localStorage — clear during development if schema changes
- **iOS simulator must be booted before `pnpm tauri ios dev`** — run `xcrun simctl boot "iPhone 16"` first
- Closures in Rust arrays must be the same type — use sequential if/else instead
- Tauri 2.x uses `invoke` from `@tauri-apps/api/core` (not `@tauri-apps/api`)
- `tauri.conf.json` identifier should not end with `.app` on macOS
- SQLite queries use `?1, ?2` params, not `$1, $2`
- App identifier is `com.emailbudget.app`
